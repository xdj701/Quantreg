// [[Rcpp::depends(RcppArmadillo)]]

#include <RcppArmadillo.h>
#include <cmath>
#include <RcppArmadilloExtensions/sample.h>

using namespace Rcpp;

List pfn(NumericMatrix x, NumericVector y, double tau, double Mm_factor, int max_bad_fixup, double eps);
NumericMatrix sub_matrix(NumericMatrix mat, IntegerVector samp, bool row_or_col);
NumericVector sub_vector(NumericVector vec, IntegerVector samp);
NumericMatrix cross_chol_inv(NumericMatrix x);
NumericMatrix times_sqrt(NumericMatrix x, NumericMatrix xxinv, NumericVector p);
IntegerVector trueVector(LogicalVector x);
NumericMatrix rbind(NumericMatrix mat, NumericVector vec);
NumericVector cbind(NumericVector vec, double val);
NumericVector glob_transform(NumericMatrix mat, LogicalVector vec);
LogicalVector combine_logic(LogicalVector a, LogicalVector b);
int sum_or(LogicalVector a, LogicalVector b);
NumericVector mat_times_vec(NumericMatrix x, NumericVector p);

//Call R function
NumericVector quantile(NumericVector x, NumericVector probs) ;
List fnb(NumericMatrix x, NumericVector y, double tau, double beta, double eps); // need rewrite




//[[Rcpp::export]]
List pfn(NumericMatrix x, NumericVector y, double tau = 0.5,  double Mm_factor = 0.8, int max_bad_fixup = 3, double eps  = 0.000001){

	int n = y.length();
	if (x.nrow() != n) 
		stop("X and y don't match n");
	if (tau<0 || tau>1)
		stop("tau outside (0,1)");
	int p = x.ncol();
	int m = round( pow( (p+1.0)*n, 2.0/3 ) ); //Rcout<< "m= " <<m<<std::endl;
	bool not_optimal = true;
	NumericVector b(p);

	while (not_optimal){

		if ( m>=n ){
			return fnb(x,y,tau,0.99995,eps);//call fnb
		}
		else{
				IntegerVector tmp = seq_len(n); 
				IntegerVector s = RcppArmadillo::sample(tmp,m,false, NumericVector::create()); 
				NumericMatrix xx = sub_matrix(x,s-1,0);// the index in C++ starts at 0
				NumericVector yy = sub_vector(y,s-1);
				List z = fnb(xx,yy,tau,0.99995,eps);
				NumericMatrix xxinv = cross_chol_inv(xx);
				NumericMatrix band = times_sqrt(x,xxinv,NumericVector(p,1.0));
				NumericVector r = y-mat_times_vec(x,z["coefficients"]);
				double M = Mm_factor*m;
				double lo_q = std::max(1.0/n,tau-M/(2.0*n));
				double hi_q = std::min(tau+M/(2.0*n),(n-1.0)/n);
				NumericVector kappa = quantile(r/pmax(eps,band),NumericVector::create(lo_q,hi_q));
				LogicalVector su = (r > ( band*kappa(1) ) );
				LogicalVector sl = (r < ( band*kappa(0) ) );
				int bad_fixup = 0;
				while (not_optimal && ( bad_fixup < max_bad_fixup ) ){
					xx = sub_matrix(x,trueVector( (!su) & (!sl) ), 0);
					yy = sub_vector(y,trueVector( (!su) & (!sl) ) );
					if ( is_true(any(su)) ){
						NumericVector ghib_x = glob_transform(x,su);
						double ghib_y = sum( sub_vector(y,trueVector(su)) );
						xx = rbind(xx,ghib_x);
						yy = cbind(yy,ghib_y);
					}
					if ( is_true(any(sl)) ){
						NumericVector glob_x = glob_transform(x,sl);
						double glob_y = sum( sub_vector(y,trueVector(sl)) );
						xx = rbind(xx,glob_x);
						yy = cbind(yy,glob_y);
					}
					z = fnb(xx,yy,tau,0.99995,eps);
					b = z["coefficients"];
					r = y-mat_times_vec(x,z["coefficients"]);
					LogicalVector su_bad = (( r<0 ) & su);
					LogicalVector sl_bad = (( r>0 ) & sl);
					if ( is_true(any(combine_logic(su_bad,sl_bad))) ) {
						if ( sum_or(su_bad,sl_bad) > 0.1*M){
							warning("Too many fixups: doubling m");
							m = 2*m;
							break;
						}	
						su = su & (!su_bad);
						sl = sl & (!sl_bad);
						bad_fixup++;
					}
					else
						not_optimal = false;
				}
		}
	}
	NumericVector coefficients(b);
	coefficients.attr("names") = colnames(x);
	return List::create(Named("coefficients") = coefficients, Named("tau") = tau, Named("residuals") = y-mat_times_vec(x,coefficients));

}


NumericMatrix cross_chol_inv(NumericMatrix x){

	arma::mat x_arma(x.begin(),x.nrow(),x.ncol(),false);

	arma::mat tmp = arma::trans(x_arma)*x_arma;

	arma::mat rt = arma::inv( arma::chol( tmp ) );

	return as<NumericMatrix>(wrap(rt));
}

NumericMatrix times_sqrt(NumericMatrix x, NumericMatrix xxinv, NumericVector p){

	arma::mat x_arma(x.begin(),x.nrow(),x.ncol(),false);
	arma::mat xxinv_arma(xxinv.begin(),xxinv.nrow(),xxinv.ncol(),false);
	arma::mat p_arma(p.begin(),p.length(),1,false);

	arma::mat tmp = arma::pow((x_arma)*xxinv_arma,2);
	arma::mat rt = arma::sqrt(tmp*p_arma);

	return as<NumericMatrix>(wrap(rt));
}

//copy the sub-matrix into new matrix
NumericMatrix sub_matrix(NumericMatrix mat, IntegerVector samp, bool row_or_col){
	
	if (!row_or_col){

		int row = samp.length();
		int col = mat.ncol();
		IntegerVector sub_vec( col );
		NumericMatrix rt( row,col );
	
		// need modification by Range()
		for (int i = 0; i< row; i++){
			rt(i,_) = mat(samp[i],_);
		}
		return rt;
	}
	else{

		int row = mat.nrow();
		int col = samp.length();
		IntegerVector sub_vec( row );
		NumericMatrix rt( row,col );
	
		for (int i = 0; i< col; i++){
			rt(_,i) = mat(_,samp[i]);
		}
		return rt;
	}

}

//copy the sub-vector into new vector
NumericVector sub_vector(NumericVector vec, IntegerVector samp){
	
	int len = samp.length();
	NumericVector rt(len);
	for (int i=0; i<len; i++){
		rt(i) = vec(samp[i]);
	}
	return rt;
}

NumericVector quantile(NumericVector x, NumericVector probs) {

	Environment stats("package:stats");
	Function quantile = stats["quantile"];
	int npr = probs.size();
	NumericVector ans(npr);
	for(int i=0; i<npr; i++){
		ans[i] = as<double>(quantile(x, probs[i]));
  	}
  	return ans;
}

//[[Rcpp::export]]
List fnb(NumericMatrix x, NumericVector y, double tau = 0.5, double beta = 0.99995, double eps = 0.000001) {

	Environment stats("package:quantreg");
	Function fnb = stats["rq.fit.fnb"];
	return fnb(x,y,tau,beta,eps);
}

IntegerVector trueVector(LogicalVector x) {

	std::vector<int> count;
	for (int i =0; i<x.length(); i++){
		if (x[i] == true)
			count.push_back(i);
	}

	return as<IntegerVector>(wrap(count));
}

NumericMatrix rbind(NumericMatrix mat, NumericVector vec){

	if (mat.ncol() != vec.length())
		stop("matrix and vector don't match col");
	int new_nrow = mat.nrow()+1;
	NumericMatrix rt(new_nrow,mat.ncol());
	
	for (int i = 0; i< new_nrow-1; i++){
		rt(i,_) = mat(i,_);
	}	
	rt(new_nrow-1,_) = vec;
	return rt;
}

NumericVector cbind(NumericVector vec, double val){

	int new_len = vec.length()+1;
	NumericVector rt(new_len);
	for (int i = 0; i< new_len-1; i++){
		rt[i] = vec[i];
	}	
	rt[new_len-1] = val;
	return rt;
}

NumericVector glob_transform(NumericMatrix mat, LogicalVector vec){

	NumericMatrix sub = sub_matrix(mat,trueVector(vec),0);
	NumericVector rt(sub.ncol());

	for (int i =0; i<rt.length(); i++){
		for (int j = 0; j < sub.nrow(); j++)
			rt[i] += sub(j,i);
	}
	return rt;
}

LogicalVector combine_logic(LogicalVector a, LogicalVector b){

	int na = a.length(), nb = b.length();
	LogicalVector rt(na+nb);
	for (int i = 0; i<na ; i++)
		rt[i] = a[i];
	for (int j = 0; j<nb ; j++)
		rt[na+j] = b[j];
	return rt;
}

int sum_or(LogicalVector a, LogicalVector b){

	LogicalVector or_gate = a|b;
	int count = 0;
	for (int i =0; i<or_gate.length(); i++)
		if (or_gate[i] == true)
			count++;
	return count;
}

NumericVector mat_times_vec(NumericMatrix x, NumericVector p){

	arma::mat x_arma(x.begin(),x.nrow(),x.ncol(),false);
	arma::mat p_arma(p.begin(),p.length(),1,false);
	return as<NumericVector>(wrap(x_arma*p_arma));
}
